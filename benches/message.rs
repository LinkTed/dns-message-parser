use bytes::Bytes;
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use dns_message_parser::Dns;
use std::time::Duration;

static A: &[u8; 45] =
    b"\xdb\x1c\x85\x80\x00\x01\x00\x01\x00\x00\x00\x00\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x6f\x72\
    \x67\x00\x00\x01\x00\x01\xc0\x0c\x00\x01\x00\x01\x00\x00\x0e\x10\x00\x04\x0a\x00\x00\x0a";

static NS: &[u8; 97] =
    b"\x03\x78\x85\x80\x00\x01\x00\x02\x00\x00\x00\x02\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x6f\x72\
    \x67\x00\x00\x02\x00\x01\xc0\x0c\x00\x02\x00\x01\x00\x00\x0e\x10\x00\x06\x03\x6e\x73\x31\xc0\
    \x0c\xc0\x0c\x00\x02\x00\x01\x00\x00\x0e\x10\x00\x06\x03\x6e\x73\x32\xc0\x0c\xc0\x29\x00\x01\
    \x00\x01\x00\x00\x0e\x10\x00\x04\x7f\x00\x00\x01\xc0\x3b\x00\x01\x00\x01\x00\x00\x0e\x10\x00\
    \x04\x0a\x00\x00\x01";

static CNAME: &[u8; 49] =
    b"\xe2\x7b\x85\x80\x00\x01\x00\x01\x00\x00\x00\x00\x05\x63\x6e\x61\x6d\x65\x07\x65\x78\x61\x6d\
    \x70\x6c\x65\x03\x6f\x72\x67\x00\x00\x05\x00\x01\xc0\x0c\x00\x05\x00\x01\x00\x00\x0e\x10\x00\
    \x02\xc0\x12";

static SOA: &[u8; 75] =
    b"\xeb\x9c\x85\x80\x00\x01\x00\x01\x00\x00\x00\x00\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x6f\x72\
    \x67\x00\x00\x06\x00\x01\xc0\x0c\x00\x06\x00\x01\x00\x00\x0e\x10\x00\x22\x03\x6e\x73\x31\xc0\
    \x0c\x05\x61\x64\x6d\x69\x6e\xc0\x0c\x00\x00\x00\x01\x00\x00\x2a\x30\x00\x00\x0e\x10\x00\x09\
    \x3a\x80\x00\x00\x0e\x10";

static PTR: &[u8; 64] =
    b"\x0c\x72\x85\x80\x00\x01\x00\x01\x00\x00\x00\x00\x02\x31\x30\x01\x30\x01\x30\x02\x31\x30\x07\
    \x65\x78\x61\x6d\x70\x6c\x65\x03\x6f\x72\x67\x00\x00\x0c\x00\x01\xc0\x0c\x00\x0c\x00\x01\x00\
    \x00\x0e\x10\x00\x0d\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x6f\x72\x67\x00";

static MESSAGES: [(&[u8], &str); 5] = [
    (A, "a"),
    (NS, "NS"),
    (CNAME, "CNAME"),
    (SOA, "SOA"),
    (PTR, "PTR"),
];

fn decode(c: &mut Criterion) {
    let mut group = c.benchmark_group("decode");
    for (dns, name) in MESSAGES.iter() {
        let dns = Bytes::from_static(dns);
        let name = name.to_owned();
        let throughput = Throughput::Bytes(dns.len() as u64);
        let benchmark_id = BenchmarkId::new(name, dns.len());
        group.throughput(throughput);
        group.bench_with_input(benchmark_id, &dns, |b, dns| {
            b.iter(|| Dns::decode(dns.clone()).unwrap())
        });
    }
    group.finish();
}

fn encode(c: &mut Criterion) {
    let mut group = c.benchmark_group("encode");
    for (dns, name) in MESSAGES.iter() {
        let dns = Bytes::from_static(dns);
        let dns = Dns::decode(dns).unwrap();
        let bytes = dns.encode().unwrap();
        let name = name.to_owned();
        let throughput = Throughput::Bytes(bytes.len() as u64);
        let benchmark_id = BenchmarkId::new(name, bytes.len());
        group.throughput(throughput);
        group.bench_with_input(benchmark_id, &dns, |b, dns| {
            b.iter(|| dns.encode().unwrap())
        });
    }
    group.finish();
}

criterion_group! {
    name = benches;
    config = Criterion::default()
        .sample_size(1024)
        .measurement_time(Duration::from_secs(10));
    targets = decode, encode
}
criterion_main!(benches);
